This was all about logging in through a webpage using SQL injection. The task was to bypass the login system and find a hidden flag. Here are the steps I took and how I managed to solve it.

## Process

### Step 1: Attempting to Log In

![Screenshot (31)](https://github.com/user-attachments/assets/30c91cb5-6d7d-4b2f-8c7e-c5b7a95309f0)


![Screenshot (33)](https://github.com/user-attachments/assets/b82c1702-901d-4f0b-947c-01bbf7468781)


My first thought was to try the most obvious credentials: `admin` for both the username and password. After entering these, I noticed the system generated the following SQL query:

![Screenshot (32)](https://github.com/user-attachments/assets/98d36277-c5b0-4577-a0bd-f9cfeb1dd7a1)


![Screenshot (34)](https://github.com/user-attachments/assets/5fa9d12d-0c57-4538-929c-ea85f0364b78)


Unfortunately, this attempt failed, displaying a message that the login credentials were incorrect. Clearly, the system was set up to handle these default values.

### Step 2: Testing Different Passwords

I tried a different password next, such as `hello`, but the login still failed. This confirmed that the system was indeed checking the provided credentials against the database records.

![Screenshot (35)](https://github.com/user-attachments/assets/9958b229-7bbf-4c1a-b04a-8d6d9408c425)


### Step 3: Observing the SQL Query

Upon examining the SQL query generated by the login attempt, it became clear that the system directly inserted the user inputs into the SQL statement. This looked like a potential vulnerability point:

```sql
SELECT * FROM users WHERE name='admin' AND password='admin'
```

### Step 4: Crafting a SQL Injection Payload

To exploit this vulnerability, I crafted a SQL injection payload to manipulate the SQL query:

```
' OR 1=1--
```

This payload works by ending the password string and adding an OR condition that always evaluates to true. The modified SQL query looked like this:

```sql
SELECT * FROM users WHERE name='admin' AND password='' OR 1=1--
```

Since `1=1` is always true, this condition bypassed the password check, allowing me to log in without needing a valid password.

### Step 5: Logging In Successfully

Using the SQL injection payload, I successfully logged in. The page now showed that I was logged in, but the flag still wasn't immediately visible. The challenge prompt hinted that the flag was hidden within the source code.

![Screenshot (36)](https://github.com/user-attachments/assets/9bd98d7f-6a30-4009-a7f4-bbbfd1cb332d)


### Step 6: Inspecting the Source Code

I opened the browser's developer tools and carefully inspected the HTML source code of the logged-in page. There, I found a hidden paragraph element that contained the flag:

![Screenshot (37)](https://github.com/user-attachments/assets/f45b3514-c954-4128-9d84-cb8ffec85025)


The flag was right there, cleverly hidden in the source code. This step emphasized the importance of thoroughly checking every aspect of a web page during a challenge.

## Conclusion

This challenge was a great exercise in understanding and exploiting SQL injection vulnerabilities. By carefully crafting my inputs, I was able to manipulate the SQL query and bypass the login mechanism. Here's a summary of the key steps:

1. Identifying the SQL query generated by the login form.
2. Using a SQL injection payload to bypass the password check.
3. Analyzing the source code to uncover the hidden flag.

This experience reinforced the critical importance of secure coding practices and input validation in web applications. 

**picoCTF{L00k5_l1k3_y0u_solv3d_it_9b0a4e21}**
